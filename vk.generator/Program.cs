//
// Program.cs
//
// Author:
//       Jean-Philippe Bruyère <jp_bruyere@hotmail.com>
//
// Copyright (c) 2019 jp
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

#define VULKAN_1_0
#define VULKAN_1_1

using System;
using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Xml;
using System.Linq;

namespace vk.generator {


	#region ExtensionsMethods
	public static class ExtensionsMethods {
		public static string RemoveCommonLeadingPart (this string s, string other) {
			string tmp = "";
			string tmp2 = other.Replace ("Flags", "");
			//tmp2 = tmp2.Replace ("Type", "");

			foreach (string tag in Generator.tags) {
				if (tmp2.EndsWith (tag, StringComparison.Ordinal)) {
					tmp2 = tmp2.Remove (tmp2.Length - tag.Length);
					break;
				}
			}

			for (int i = 0; i < tmp2.Length; i++) {
				if (s[i] != tmp2[i]) {
					tmp = s.Substring (i);
					break;
				}
			}
			if (string.IsNullOrEmpty (tmp))
				tmp = s.Substring (tmp2.Length);
			if (char.IsNumber (tmp[0])) {
				tmp2 = tmp2.Replace ("Type", "");
				return //other.EndsWith ("flagbits", StringComparison.OrdinalIgnoreCase) ?
					   //tmp2.Substring (2).Remove (tmp2.Length - 10) + tmp :
					   //other.EndsWith ("type", StringComparison.OrdinalIgnoreCase) ?
					   //tmp2.Substring (2).Remove (tmp2.Length - 6) + tmp :
					tmp2.Substring (2) + tmp;
			}
			return tmp;
		}

		public static string ConvertUnderscoredUpperCasedNameToCamelCase (this string name) {
			string[] tmp = name.Split ('_');
			List<string> result = new List<string> ();
			for (int i = 0; i < tmp.Length; i++) {
				string s = tmp[i];
				if (s == "BIT")
					continue;
				if ((i == tmp.Length - 1 && Generator.tags.Contains (s)) || (char.IsDigit (s[0]) && s.Substring (1) == "D"))
					result.Add (s);
				else
					result.Add (s[0] + s.Substring (1).ToLower ());
			}
			return result.Aggregate ((a, b) => a + b);
		}
		public static string[] SplitCamelCased (this string cc) {
			List<string> result = new List<string> ();

			string tmp = "";
			for (int i = 0; i < cc.Length; i++) {
				if (char.IsUpper (cc[i])) {
					if (!string.IsNullOrEmpty (tmp))
						result.Add (tmp);
					tmp = "" + cc[i];
				} else
					tmp += cc[i];
			}
			if (!string.IsNullOrEmpty (tmp))
				result.Add (tmp);
			return result.ToArray ();
		}
	}
	#endregion

	public class Generator {
		const int extBase = 1000000000;
		const int extBlockSize = 1000;

		public const string vknamespace = "VK";
		public const string vkCommonCmdClassName = "Vk";
		public const string heading = "/* autogenerated with http://github.com/jpbruyere/vk.net */";
		public static string[] defaultUsings = { "System" };

		public static Dictionary<string, string> knownTypes = new Dictionary<string, string> {
			{"uint8_t",             "byte"},
			{"char",                "byte"},
			{"uint16_t",            "ushort"},
			{"uint32_t",            "uint"},
			{"uint64_t",            "ulong"},
			{"int16_t",             "short"},
			{"int32_t",             "int"},
			{"int64_t",             "long"},
			{"size_t",              "UIntPtr"},
			{"VkSampleMask",        "uint"},
			{"VkDeviceSize",        "ulong"},
			{"VkDeviceAddress",     "ulong"},

			{"HMONITOR",            "IntPtr"},

			{ "DWORD", "uint" },

			{ "ANativeWindow", "Android.ANativeWindow" },

			{ "MirConnection", "Mir.MirConnection" },
			{ "MirSurface", "Mir.MirSurface" },

			{ "wl_display", "Wayland.wl_display" },
			{ "wl_surface", "Wayland.wl_surface" },

			{ "Display", "Xlib.Display" },
			{ "Window", "Xlib.Window" },
			{ "VisualID", "Xlib.VisualID" },
			{ "RROutput", "IntPtr" },

			{ "HINSTANCE", "Win32.HINSTANCE" },
			{ "HWND", "Win32.HWND" },
			{ "HANDLE", "Win32.HANDLE" },
			{ "SECURITY_ATTRIBUTES", "Win32.SECURITY_ATTRIBUTES" },
			{ "LPCWSTR", "IntPtr" },

			{ "xcb_connection_t", "Xcb.xcb_connection_t" },
			{ "xcb_window_t", "Xcb.xcb_window_t" },
			{ "xcb_visualid_t", "Xcb.xcb_visualid_t" },

			//those are not checked, just putted there for compiling
            { "GgpFrameToken", "uint" },	//cant find header to check length
			{ "zx_handle_t", "ulong" },
			{ "GgpStreamDescriptor", "ulong" },
			{ "PFN_vkVoidFunction","IntPtr" },
			{ "AHardwareBuffer", "Android.ANativeWindow" },//must be corrected

        };

		static string[] skipEnums = { "VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES2_EXT" };

		static Dictionary<string, string[]> paramTypeAliases = new Dictionary<string, string[]> {
			{ "void*", new string[] {"IntPtr"} },
			{ "char*", new string[] {"string"} }
		};

		public static Dictionary<string, string> aliases = new Dictionary<string, string> ();
		static void AddAlias (string from, string to) {
			if (to == "VkFlags")//dont alias to VkFlags
				return;
			if (aliases.ContainsKey (from))
				Console.WriteLine ($"aliases list constains already an alias for: {from}");
			else
				aliases.Add (from, to);
			Console.ForegroundColor = ConsoleColor.Green;
			Console.WriteLine ($"adding alias {from} -> {to}");
			Console.ForegroundColor = ConsoleColor.Gray;
		}

		enum EnumTypes { bitmask, @enum };
		enum ExtensionType { None, Device, Instance }
		enum TypeCategories {none, basetype, bitmask, define, @enum, funcpointer, group, handle, include, @struct, @union };

		//those command should not move in other iface than common to be preload by normal dyn load
		static string[] preloadedCommands  = { "vkCreateInstance", "vkDestroyInstance", "vkGetDeviceProcAddr", "vkGetInstanceProcAddr" };
		static string[] reservedNames = { "event", "object" };

		static Dictionary<string, ParamDef> paramsDefs = new Dictionary<string, ParamDef> ();

		public static List<string> tags = new List<string> ();


		class Definition {
			public List<string> definedBy = new List<string>();
			protected string name;
			public string comment;
			public override string ToString () => this.GetType ().Name + ":" + name;

			public string Name {
				get { return reservedNames.Contains (name) ? "_" + name : name; }
				set { name = value; }
			}
			public virtual string CSName {
				get {
					string tmp = name.Replace ("FlagBits", "Flags");
					while (Generator.aliases.ContainsKey (tmp)) //recurse in aliases
						tmp = Generator.aliases[tmp];

					return (Generator.knownTypes.ContainsKey (tmp) ? Generator.knownTypes[tmp] : tmp);
				}
			}
		}

		class StructDef : TypeDef {
			public List<MemberDef> members = new List<MemberDef> ();
		}
		class TypeDef : Definition {
			public TypeCategories category;
			public string baseType;
			public string require;
		}
		class EnumDef : Definition {
			//public string require;
			public EnumTypes type;
			public int start;
			public int end;
			public string vendor;

			public List<EnumerantValue> values = new List<EnumerantValue> ();
		}
		class HandleDef : TypeDef {
			public string parent;
			public bool nonDispatchable => baseType == "VK_DEFINE_NON_DISPATCHABLE_HANDLE";
		}
		class ParamDef : Definition {
			public string txtbefore;
			public string txtafter;

			public static ParamDef parse (XmlNode n) {
				XmlNode t = n["type"];
				ParamDef tmp = new ParamDef ();
				tmp.name = t.InnerText;
				if (t.PreviousSibling?.NodeType == XmlNodeType.Text)
					tmp.txtbefore = t.PreviousSibling.Value;
				if (t.NextSibling?.NodeType == XmlNodeType.Text)
					tmp.txtafter = t.NextSibling.Value;

				if (paramsDefs.ContainsKey (tmp.FullCTypeDecl))
					return paramsDefs[tmp.FullCTypeDecl];

				paramsDefs.Add (tmp.FullCTypeDecl, tmp);

				return tmp;
			}

			public string FullCTypeDecl {
				get { return txtbefore + name + txtafter; }
			}
			public int IndirectionLevel {
				get {
					if (string.IsNullOrEmpty (txtafter))
						return 0;
					int i = 0;
					foreach (char c in txtafter) {
						if (c == '*')
							i++;
					}
					return i;
				}
			}
			public bool IsStruct {
				get { return string.IsNullOrEmpty (txtbefore) ? false : txtbefore.Contains ("struct"); }
			}
			public bool IsConst {
				get { return string.IsNullOrEmpty (txtbefore) ? false : txtbefore.Contains ("const"); }
			}
			public override string ToString () {
				return FullCTypeDecl;
			}
		}
		class MemberDef : Definition {
			public ParamDef typedef;

			public bool isReadOnly;
			public bool optional;
			public bool externsync;
			public bool nullTerminated;
			public string lenMember;
			public string defaultValue;
			public string fixedArray;

			public override string ToString () {
				return string.Format ($"memberdef: {typedef.FullCTypeDecl} {name}");
			}
		}

		class EnumerantValue : Definition, IEquatable<EnumerantValue>{//name is not yet converted to csname!!
			public string unusedComment;
			public string extends;
			public string value;
			public bool isAlias;
			public override string ToString () => string.Format ($"{name} = {value}");
			public override string CSName => throw new NotImplementedException (); //name.ConvertUnderscoredUpperCasedNameToCamelCase ();

			public string GetCSName (string containingType = null) {
				return GetCSName (name, containingType);
				// name.ConvertUnderscoredUpperCasedNameToCamelCase ().RemoveCommonLeadingPart (containingType.CSName);
			}
			public static string GetCSName (string value, string containingType) {
				return containingType == null ?
					value.ConvertUnderscoredUpperCasedNameToCamelCase () :
				 	value.ConvertUnderscoredUpperCasedNameToCamelCase ().RemoveCommonLeadingPart (containingType);
			}

			public bool Equals (EnumerantValue other) {
				return name == other.name;
			}
			public override bool Equals(object obj){
			     if(obj == null) return false;
				return name == (obj as EnumerantValue).name;
			}
			public override int GetHashCode(){
			     return value.GetHashCode();
			}
		}

		class FuncpointerDef : TypeDef {
			public ParamDef returnType;
			public List<MemberDef> parameters = new List<MemberDef> ();
		}
		class CommandDef : FuncpointerDef {
			public string alias;
			public string successCodes;
			public string errorcodes;
		}

		static List<TypeDef> types = new List<TypeDef> ();
		static List<EnumDef> enums = new List<EnumDef> ();
		static List<CommandDef> commands = new List<CommandDef> ();
		static List<EnumerantValue> extends = new List<EnumerantValue> ();
		static List<EnumerantValue> Constants = new List<EnumerantValue> ();

		class InterfaceDef : Definition {
			public int number;
		}
		class FeatureDef : InterfaceDef {
			public string api;
			public int major;
			public int minor;
		}
		class ExtensionDef : InterfaceDef {
			public ExtensionType type;
			public string supported;
			public string[] requires;

			//public string platform;
		}

		static List<FeatureDef> features = new List<FeatureDef> ();
		static List<ExtensionDef> extensions = new List<ExtensionDef> ();

		#region code generation
		static void writePreamble (IndentedTextWriter tw, params string[] additionalUsings) {
			tw.WriteLine (heading);
			foreach (string @using in defaultUsings)
				tw.WriteLine ($"using {@using};");
			foreach (string @using in additionalUsings)
				tw.WriteLine ($"using {@using};");
			tw.WriteLine ($"namespace {vknamespace} {{");
		}

		static void writeStructNew (IndentedTextWriter tw, StructDef sd) {
			MemberDef md = sd.members.Where (mb => mb.Name == "sType").First ();
			TypeDef sType = types.Where (
				edd => edd.category == TypeCategories.@enum && edd.Name == md.typedef.Name).First ();				

			tw.WriteLine ($"public static {sd.Name} New () {{");
			tw.Indent++;

			tw.WriteLine ($"return new {sd.Name} {{");
			tw.Indent++;

			//string defV = sd.members.Where (mb => mb.Name == "sType").FirstOrDefault ().defaultValue.ConvertUnderscoredUpperCasedNameToCamelCase ();

			//tw.WriteLine ($"sType = {sType.CSName}.{ev.GetCSName (sType.CSName)},");
			tw.WriteLine ($"sType = {sType.CSName}.{EnumerantValue.GetCSName (md.defaultValue, sType.CSName)},");
			tw.WriteLine ($"pNext = IntPtr.Zero");
			tw.Indent--;
			tw.WriteLine (@"};");
			tw.Indent--;
			tw.WriteLine (@"}");
		}

		static void gen_struct (IndentedTextWriter tw, StructDef sd) {
			tw.WriteLine ($"public partial struct {sd.Name} {{");
			tw.Indent++;
			foreach (MemberDef mb in sd.members) {
				if (!string.IsNullOrEmpty (mb.comment))
					tw.WriteLine ($"/// <summary> {mb.comment} </summary>");

				string typeStr;
				if (mb.typedef.IndirectionLevel > 0)
					typeStr = "IntPtr";
				else
					typeStr = mb.typedef.CSName;

				if (!string.IsNullOrEmpty (mb.fixedArray)) {
					int dim = 0;
					if (int.TryParse (mb.fixedArray, out dim)) {
						tw.WriteLine ($"[MarshalAs (UnmanagedType.ByValArray, SizeConst = {dim})]");
					} else { 
						tw.WriteLine ($"[MarshalAs (UnmanagedType.ByValArray, SizeConst = (int)Vk.{EnumerantValue.GetCSName(mb.fixedArray,null).Substring(2)})]");
					}
					typeStr += "[]";
				}

				tw.WriteLine ($"public {typeStr} {mb.Name};");
			}

			if (sd.members.Any (mb => mb.Name == "sType" && !string.IsNullOrEmpty (mb.defaultValue)))
				writeStructNew (tw, sd); ;

			tw.Indent--;
			tw.WriteLine (@"}");
		}

		static void gen_structs (string englobingStaticClass) {
			using (StreamWriter sr = new StreamWriter ($"structs_{englobingStaticClass}_gen.cs", false, System.Text.Encoding.UTF8)) {
				using (IndentedTextWriter tw = new IndentedTextWriter (sr)) {
					writePreamble (tw, "System.Runtime.InteropServices");
					tw.Indent++;

					//tw.WriteLine ($"public static partial class {englobingStaticClass} {{");
					//tw.Indent++;

					foreach (StructDef sd in types.OfType<StructDef> ())//.Where(t=>t.definedBy.Count == 0))
						gen_struct (tw, sd);

					//foreach (FeatureDef fd in features) {
					//	tw.WriteLine ($"#if {fd.Name}");

					//	foreach (StructDef sd in fd.types.OfType<StructDef>())
					//		gen_struct (tw, fd, sd);					

					//	tw.WriteLine ("#endif");
					//}
					//foreach (ExtensionDef fd in extensions) {
					//	foreach (StructDef sd in fd.types.OfType<StructDef>())
					//		gen_struct (tw, fd, sd);					
					//}					
					//tw.Indent--;
					//tw.WriteLine (@"}");

					tw.Indent--;
					tw.WriteLine (@"}");
				}
			}
		}
		static void write_empty_enum_as_struct (IndentedTextWriter tw, EnumDef enumType) { 
			tw.WriteLine (@"[DebuggerDisplay(""{DebuggerDisplay,nq}"")]");
			tw.WriteLine ($"public struct {enumType.CSName} : IEquatable<{enumType.CSName}>");
			tw.WriteLine (@"{");
			tw.Indent++;

			string hType = "uint";

			tw.WriteLine ($"public readonly {hType} Value;");
			tw.WriteLine ($"public {enumType.CSName}({hType} existingHandle) {{ Value = existingHandle; }}");
			tw.WriteLine ($"public static {enumType.CSName} Null => new {enumType.CSName}(0);");
			tw.WriteLine ($"public static implicit operator {enumType.CSName}({hType} flags) => new {enumType.CSName}(flags);");
			tw.WriteLine ($"public static bool operator ==({enumType.CSName} left, {enumType.CSName} right) => left.Value == right.Value;");
			tw.WriteLine ($"public static bool operator !=({enumType.CSName} left, {enumType.CSName} right) => left.Value != right.Value;");
			tw.WriteLine ($"public static bool operator ==({enumType.CSName} left, {hType} right) => left.Value == right;");
			tw.WriteLine ($"public static bool operator !=({enumType.CSName} left, {hType} right) => left.Value != right;");
			tw.WriteLine ($"public bool Equals({enumType.CSName} h) => Value == h.Value;");
			tw.WriteLine ($"public override bool Equals(object obj) => obj is {enumType.CSName} h && Equals(h);");
			tw.WriteLine ($"public override int GetHashCode() => Value.GetHashCode();");
			tw.WriteLine ($"private string DebuggerDisplay => string.Format(\"{enumType.CSName} [0x{{0}}]\", Value.ToString(\"X\"));");

			tw.Indent--;
			tw.WriteLine (@"}");
		}

		static void gen_enum_value (IndentedTextWriter tw, string enumName, EnumerantValue ev) {
			if (!string.IsNullOrEmpty (ev.comment))
				tw.WriteLine ($"/// <summary> {ev.comment} </summary>");
			if (!string.IsNullOrEmpty (ev.unusedComment))
				tw.WriteLine ($"[Obsolete(\"{ev.unusedComment}\"]");

			uint v;
			string vName = ev.GetCSName (enumName);

			if (uint.TryParse (ev.value, out v))
				tw.WriteLine ($"{vName,-50} = 0x{v.ToString ("X8")},");
			else if (ev.isAlias) {
				string alias = EnumerantValue.GetCSName (ev.value, enumName);
				tw.WriteLine ($"{vName,-50} = {alias,10},");
			} else
				tw.WriteLine ($"{vName,-50} = {ev.value,10},");
		}
		static void gen_enums (string englobingStaticClass) {
			using (StreamWriter sr = new StreamWriter ($"enums_{englobingStaticClass}_gen.cs", false, System.Text.Encoding.UTF8)) {
				using (IndentedTextWriter tw = new IndentedTextWriter (sr)) {
					writePreamble (tw, "System.Diagnostics");
					tw.Indent++;

					//foreach (TypeDef td in types.Where(t=>t.category == TypeCategories.bitmask)) {

					//	if (string.IsNullOrEmpty (td.require)) { 
					//		AddAlias (td.Name, "uint");
					//		continue;
					//	}

					//	EnumDef ed = enums.Where (e => e.Name == td.require).FirstOrDefault();

					//	if (ed == null)
					//		Debugger.Break ();

					//	if (!string.IsNullOrEmpty (ed?.comment))
					//		tw.WriteLine ($"/// <summary> {ed.comment} </summary>");
					//	tw.WriteLine (@"[Flags]");
					//	tw.WriteLine ($"public enum {td.CSName} : uint {{");

					//	tw.Indent++;

					//	foreach (EnumerantValue ev in ed.values) 
					//		gen_enum_value (tw, td.CSName, ev);

					//	tw.Indent--;
					//	tw.WriteLine (@"}");
					//}

					//foreach (TypeDef td in types.Where (t => t.category == TypeCategories.@enum)) {
					//	if (td.CSName == "uint")
					//		continue;

					//	EnumDef ed = enums.Where (e => e.Name == td.Name).FirstOrDefault();

					//	if (ed == null)	{
					//		AddAlias (td.Name, "uint");
					//		continue;
					//	}

					//	if (!string.IsNullOrEmpty (ed?.comment))
					//		tw.WriteLine ($"/// <summary> {ed.comment} </summary>");
					//	tw.WriteLine ($"public enum {td.CSName} {{");

					//	tw.Indent++;

					//	foreach (EnumerantValue ev in ed.values) 
					//		gen_enum_value (tw, td.CSName, ev);

					//	tw.Indent--;
					//	tw.WriteLine (@"}");
					//}

					//add uint alias for all type bitmask without flagbits enum
					foreach (TypeDef tdbm in types.Where (t => t.category == TypeCategories.bitmask && string.IsNullOrEmpty (t.require)))
						AddAlias (tdbm.Name, "uint");

					foreach (EnumDef ed in enums.Where(e=>e.definedBy.Count()==0)) {
						//search type
						TypeDef td = ed.type == EnumTypes.@enum ?
							types.Where(t=>t.Name == ed.Name).FirstOrDefault() :
						 	types.Where(t=>t.require == ed.Name).FirstOrDefault();

						if (td == null) {
							AddAlias (ed.Name, "uint");
							continue;
						}

						if (!string.IsNullOrEmpty (ed?.comment))
							tw.WriteLine ($"/// <summary> {ed.comment} </summary>");
						if (ed?.type == EnumTypes.bitmask) {
							tw.WriteLine (@"[Flags]");
							tw.WriteLine ($"public enum {td.CSName} : uint {{");
						} else
							tw.WriteLine ($"public enum {td.CSName} {{");


						tw.Indent++;

						foreach (EnumerantValue ev in ed.values) 
							gen_enum_value (tw, td.CSName, ev);

						IEnumerable<EnumerantValue> ext = extends.Where (e => e.extends == ed.Name);
						foreach (EnumerantValue ev in ext) 
							gen_enum_value (tw, td.CSName, ev);


						tw.Indent--;
						tw.WriteLine (@"}");
					}
			//				if (ed != null) {
			//					enumerantName = ed.CSName;
			//					foreach (EnumerantValue ev in ed.values)
			//						gen_enum_value (tw, enumName, ev);
			//				}

			//				//IEnumerable<EnumerantValue> exts = (extensions.SelectMany (ext => ext.extends).Where (ex2 => ex2.extends == enumerantName));

			//				//List<EnumerantValue> addedVal = new List<EnumerantValue> ();
			//				//foreach (EnumerantValue ev in exts) {
			//				//	if (addedVal.Contains (ev))
			//				//		continue;
			//				//	gen_enum_value (tw, enumName, ev);
			//				//	addedVal.Add (ev);
			//				//}
			//				/*foreach (ExtensionDef ex in extensions) {
			//					IEnumerable<EnumerantValue> extends = ex.extends.Where (ex2 => ex2.extends == enumerantName);
			//					if (extends.Count () == 0)
			//						continue;
			//					tw.WriteLine ($"#if {ex.Name}");
			//					foreach (EnumerantValue ev in extends)
			//						gen_enum_value (tw, enumName, ev);
			//					tw.WriteLine ("#endif");
			//				}*/

			//				//foreach (FeatureDef fd in featToProcessForEnumValues) {
			//				//	IEnumerable<EnumerantValue> exs = extends.Where (ex => ex.extends == enumerantName);

			//				//	if (exs.Count () == 0)
			//				//		continue;
			//				//	tw.WriteLine ($"#if {fd.Name}");
			//				//	foreach (EnumerantValue ev in exs) {
			//				//		//if (exts.Contains (ev))
			//				//			//continue;
			//				//		gen_enum_value (tw, enumName, ev);
			//				//	}
			//				//	tw.WriteLine ("#endif");
			//				//}




			//			if (i > 0)
			//				tw.WriteLine ("#endif");

			//			if (i < featuresCount) {
			//				curIFace = featToProcessForEnumValues[0];
			//				tw.WriteLine ($"#if {curIFace.Name}");
			//				featToProcessForEnumValues.RemoveAt (0);
						
			//		}
			//		//tw.Indent--;
			//		//tw.WriteLine (@"}");

					tw.Indent--;
					tw.WriteLine (@"}");
				}
			}
		}
		static void gen_extensions () {
			using (StreamWriter sr = new StreamWriter ("extensions_gen.cs", false, System.Text.Encoding.UTF8)) {
				using (IndentedTextWriter tw = new IndentedTextWriter (sr)) {
					writePreamble (tw);
					tw.Indent++;

					tw.WriteLine (@"public static class Ext {");
					tw.Indent++;

					tw.WriteLine (@"public static class I {");
					tw.Indent++;
					foreach (ExtensionDef ed in extensions.Where (e => e.type == ExtensionType.Instance)) {
						tw.WriteLine ($"public static readonly string {ed.Name,-50} = \"{ed.Name}\";");
					}
					tw.Indent--;
					tw.WriteLine (@"}");

					tw.WriteLine (@"public static class D {");
					tw.Indent++;
					foreach (ExtensionDef ed in extensions.Where (e => e.type == ExtensionType.Device)) {
						tw.WriteLine ($"public static readonly string {ed.Name,-50} = \"{ed.Name}\";");
					}
					tw.Indent--;
					tw.WriteLine (@"}");

					tw.Indent--;
					tw.WriteLine (@"}");

					tw.Indent--;
					tw.WriteLine (@"}");
				}
			}
		}
		static void gen_funcptrs (string englobingStaticClass) {
			using (StreamWriter sr = new StreamWriter ($"funcptrs_{englobingStaticClass}_gen.cs", false, System.Text.Encoding.UTF8)) {
				using (IndentedTextWriter tw = new IndentedTextWriter (sr)) {
					writePreamble (tw);
					tw.Indent++;

					//tw.WriteLine ($"public static partial class {englobingStaticClass} {{");
					//tw.Indent++;

					foreach (FuncpointerDef fp in types.OfType<FuncpointerDef>())
						tw.WriteLine ($"public delegate {fp.returnType.CSName} {fp.Name} ();");					

					//tw.Indent--;
					//tw.WriteLine (@"}");

					tw.Indent--;
					tw.WriteLine (@"}");
				}
			}
		}
		static void gen_handle (IndentedTextWriter tw, HandleDef hd) { 
			tw.WriteLine (@"[DebuggerDisplay(""{DebuggerDisplay,nq}"")]");
			tw.WriteLine ($"public struct {hd.CSName} : IEquatable<{hd.CSName}>");
			tw.WriteLine (@"{");
			tw.Indent++;
			string hType = hd.nonDispatchable ? "ulong" : "IntPtr";

			tw.WriteLine ($"public readonly {hType} Handle;");
			tw.WriteLine ($"public {hd.CSName}({hType} existingHandle) {{ Handle = existingHandle; }}");
			tw.WriteLine ($"public static {hd.CSName} Null => new {hd.CSName}({(hd.nonDispatchable ? "0" : "IntPtr.Zero")});");
			tw.WriteLine ($"public static implicit operator {hd.CSName}({hType} handle) => new {hd.CSName}(handle);");
			tw.WriteLine ($"public static bool operator ==({hd.CSName} left, {hd.CSName} right) => left.Handle == right.Handle;");
			tw.WriteLine ($"public static bool operator !=({hd.CSName} left, {hd.CSName} right) => left.Handle != right.Handle;");
			tw.WriteLine ($"public static bool operator ==({hd.CSName} left, {hType} right) => left.Handle == right;");
			tw.WriteLine ($"public static bool operator !=({hd.CSName} left, {hType} right) => left.Handle != right;");
			tw.WriteLine ($"public bool Equals({hd.CSName} h) => Handle == h.Handle;");
			tw.WriteLine ($"public override bool Equals(object obj) => obj is {hd.CSName} h && Equals(h);");
			tw.WriteLine ($"public override int GetHashCode() => Handle.GetHashCode();");
			tw.WriteLine ($"private string DebuggerDisplay => string.Format(\"{hd.CSName} [0x{{0}}]\", Handle.ToString(\"X\"));");

			tw.Indent--;
			tw.WriteLine (@"}");
		}
		static void gen_handles (string englobingStaticClass) {
			using (StreamWriter sr = new StreamWriter ($"handles_{englobingStaticClass}_gen.cs", false, System.Text.Encoding.UTF8)) {
				using (IndentedTextWriter tw = new IndentedTextWriter (sr)) {
					writePreamble (tw, "System.Diagnostics");
					tw.Indent++;

					//tw.WriteLine ($"public static partial class {englobingStaticClass} {{");
					//tw.Indent++;

					foreach (HandleDef hd in types.OfType<HandleDef> ())//.Where(t=>t.definedBy.Count == 0))
						gen_handle (tw, hd);

					//foreach (FeatureDef fd in features) {
					//	tw.WriteLine ($"#if {fd.Name}");
					//	foreach (HandleDef hd in types.OfType<HandleDef> ())
					//		gen_handle (tw, hd);
					//	tw.WriteLine ("#endif");
					//}
					//tw.Indent--;
					//tw.WriteLine (@"}");

					tw.Indent--;
					tw.WriteLine (@"}");
				}
			}
		}

		static void gen_constant_value (IndentedTextWriter tw, EnumerantValue cd) {
			if (string.IsNullOrEmpty (cd.value)) { 
				Console.ForegroundColor = ConsoleColor.DarkRed;
				Console.WriteLine ("no value for constant: " + cd);
				return;
			}
			string pTrims = cd.value.Replace ("(", "");
			pTrims = pTrims.Replace (")", "");

			int i = pTrims.Length;
			while (i > 1 && char.IsLetter (pTrims[i-1]))
				i--;

			switch (pTrims.Substring(i).ToLower()) {
				case "u":
					tw.WriteLine ($"{"public const uint " + cd.GetCSName ().Substring(2),-50} = {cd.value};");
					break;
				case "ull":
					tw.WriteLine ($"{"public const ulong " + cd.GetCSName ().Substring(2),-50} = ({pTrims.Remove(pTrims.Length-1)});");
					break;
				case "f":
					tw.WriteLine ($"{"public const float " + cd.GetCSName ().Substring(2),-50} = {cd.value};");
					break;
				default:
					tw.WriteLine ($"{"public const uint " + cd.GetCSName ().Substring(2),-50} = {cd.value};");
					break;
			}
		}
		static void gen_constants (string englobingStaticClass) {
			using (StreamWriter sr = new StreamWriter ($"constants_{englobingStaticClass}_gen.cs", false, System.Text.Encoding.UTF8)) {
				using (IndentedTextWriter tw = new IndentedTextWriter (sr)) {
					writePreamble (tw);
					tw.Indent++;

					tw.WriteLine ($"public static partial class {englobingStaticClass} {{");
					tw.Indent++;

					foreach (EnumerantValue cd in Constants.Where(c=>c.definedBy.Count == 0))
						gen_constant_value (tw, cd);					

					//foreach (FeatureDef fd in features) {
					//	tw.WriteLine ($"#if {fd.Name}");

					//	foreach (EnumerantValue cd in Constants)
					//		gen_constant_value (tw, cd);					

					//	tw.WriteLine ("#endif");
					//}

					tw.Indent--;
					tw.WriteLine (@"}");

					tw.Indent--;
					tw.WriteLine (@"}");
				}
			}
		}

		static string getDefaultParamSig (MemberDef md, bool isLast) {
			switch (md.typedef.IndirectionLevel) {
				case 0:
					return (string.Format ($"{md.typedef.CSName} {md.Name}{(isLast ? ", " : ")")}"));
				case 1:
					return (string.Format ($"IntPtr {md.Name}{(isLast ? ", " : ")")}"));
				case 2:
					return (string.Format ($"ref IntPtr {md.Name}{(isLast ? ", " : ")")}"));
			}
			return null;
		}
		static string getByRefParamSig (MemberDef md, bool isLast) {
			string typeName = md.typedef.CSName == "void" ? "IntPtr" : md.typedef.CSName;
			switch (md.typedef.IndirectionLevel) {
				case 1:
					return md.typedef.IsConst ?
						(string.Format ($"ref {typeName} {md.Name}{(isLast ? ", " : ")")}")) :
						(string.Format ($"out {typeName} {md.Name}{(isLast ? ", " : ")")}"));
				case 2:
					return md.typedef.IsConst ?
						string.Format ($"ref IntPtr {md.Name}{(isLast ? ", " : ")")}") :
						string.Format ($"out IntPtr {md.Name}{(isLast ? ", " : ")")}");
			}
			return null;
		}

		static void writeCmd (IndentedTextWriter tw, string sig) {
			tw.WriteLine (@"[CalliRewrite]");
			tw.Write ($"public static {sig}");
			tw.WriteLine (@" => throw new NotImplementedException();");
		}
		static void gen_command (IndentedTextWriter tw, CommandDef cd) { 
			if (!string.IsNullOrEmpty (cd.alias)) {
				Console.ForegroundColor = ConsoleColor.DarkGray;
				Console.WriteLine ("TODO:command generator: is alias: " + cd);
				return;
			}
			tw.WriteLine ($"internal static IntPtr {cd.CSName}_ptr;");

			List<string> signatures = new List<string> () { "" };

			//if (cd.Name == "vkRegisterObjectsNVX")
				//Debugger.Break ();

			for (int i = 0; i < cd.parameters.Count; i++) {
				MemberDef md = cd.parameters[i];
				List<string> typeSigs = new List<string> () { getDefaultParamSig (md, i < cd.parameters.Count - 1) };
				if (md.typedef.IndirectionLevel == 1 && md.typedef.Name != "void")
					typeSigs.Add (getByRefParamSig (md, i < cd.parameters.Count - 1));

				string[] prevSigs = new string[signatures.Count];
				Array.Copy (signatures.ToArray (), prevSigs, prevSigs.Length);
				signatures.Clear ();
				for (int s = 0; s < prevSigs.Length; s++) {
					signatures.Add (prevSigs[s] + typeSigs[0]);
					for (int st = 1; st < typeSigs.Count; st++) {
						signatures.Add (prevSigs[s] + typeSigs[st]);
					}
				}
			}

			foreach (string sig in signatures)
				writeCmd (tw, string.Format ($"{cd.returnType.CSName} {cd.Name} ({sig}"));

			tw.WriteLine ();
		}
		static void gen_commands (string englobingStaticClass) {
			using (StreamWriter sr = new StreamWriter ($"commands_{englobingStaticClass}_gen.cs", false, System.Text.Encoding.UTF8)) {
				using (IndentedTextWriter tw = new IndentedTextWriter (sr)) {
					writePreamble (tw, vknamespace + ".Generator");
					tw.Indent++;

					tw.WriteLine ($"public static partial class {englobingStaticClass} {{");
					tw.Indent++;

					//func pointers and signature
					foreach (CommandDef cd in commands)//.Where (cmd=>cmd.definedBy.Count == 0))
						gen_command (tw, cd);

					//foreach (FeatureDef fd in features) {
					//	tw.WriteLine ($"#if {fd.Name}");

					//	foreach (CommandDef cd in commands.Where (cmd=>cmd.definedBy.Contains (fd.Name)))
					//		gen_command (tw, cd);

					//	tw.WriteLine ("#endif");
					//}
					//foreach (ExtensionDef fd in extensions) {
					//	foreach (CommandDef cd in fd.commands)
					//		gen_command (tw, cd);
					//}

					#region Function pointers loading (os, inst and dev)
					//norml dyn loading function

					tw.WriteLine (@"internal static void LoadFunctionPointers() {");
					tw.Indent++;
					foreach (string preloadCmd in preloadedCommands) {
						tw.WriteLine ($"{preloadCmd}_ptr      = Vk.s_nativeLib.LoadFunctionPointer(\"{preloadCmd}\");");
					}
					tw.WriteLine (@"Console.WriteLine (""preload function pointer ok."");");

					tw.Indent--;
					tw.WriteLine (@"}");

					//load instance func pointers
					tw.WriteLine ($"public static void LoadInstanceFunctionPointers (VkInstance inst) {{");
					tw.Indent++;
					foreach (CommandDef cd in commands){//.Where (cmd=>cmd.definedBy.Count == 0)) {
						if (!string.IsNullOrEmpty (cd.alias))
							continue;
						if (preloadedCommands.Contains (cd.Name))
							continue;
						tw.WriteLine ($"{cd.Name + "_ptr",-54} = LoadingUtils.GetDelegate (inst, \"{cd.Name}\");");
					}
					//foreach (FeatureDef fd in features) {
					//	tw.WriteLine ($"#if {fd.Name}");
					//	foreach (CommandDef cd in fd.commands) {
					//		if (!string.IsNullOrEmpty (cd.alias))
					//			continue;
					//		if (preloadedCommands.Contains (cd.Name))
					//			continue;
					//		tw.WriteLine ($"{cd.Name + "_ptr",-54} = LoadingUtils.GetDelegate (inst, \"{cd.Name}\");");
					//	}
					//	tw.WriteLine ("#endif");
					//}
					//foreach (ExtensionDef fd in extensions) {
					//	//tw.WriteLine ($"#if {fd.Name}");
					//	foreach (CommandDef cd in fd.commands) {
					//		if (!string.IsNullOrEmpty (cd.alias))
					//			continue;
					//		if (preloadedCommands.Contains (cd.Name))
					//			continue;
					//		tw.WriteLine ($"{cd.Name + "_ptr",-54} = LoadingUtils.GetDelegate (inst, \"{cd.Name}\");");
					//	}
					//	//tw.WriteLine ("#endif");
					//}
					tw.Indent--;
					tw.WriteLine (@"}");
					tw.WriteLine ();
					//load device func pointers
					tw.WriteLine ($"public static void LoadDeviceFunctionPointers (VkDevice dev) {{");
					tw.Indent++;
					foreach (CommandDef cd in commands){//.Where (cmd=>cmd.definedBy.Count == 0)) {
						if (!string.IsNullOrEmpty (cd.alias)) 
							continue;
						if (preloadedCommands.Contains (cd.Name))
							continue;
						tw.WriteLine ($"LoadingUtils.GetDelegate (dev, \"{cd.Name + "\",",-54} ref {cd.Name + "_ptr"});");
					}
					//foreach (FeatureDef fd in features) {
					//	tw.WriteLine ($"#if {fd.Name}");
					//	foreach (CommandDef cd in fd.commands) {
					//		if (!string.IsNullOrEmpty (cd.alias))
					//			continue;
					//		if (preloadedCommands.Contains (cd.Name))
					//			continue;
					//		tw.WriteLine ($"LoadingUtils.GetDelegate (dev, \"{cd.Name + "\",",-54} ref {cd.Name + "_ptr"});");
					//	}
					//	tw.WriteLine ("#endif");
					//}
					//foreach (ExtensionDef fd in extensions) {
					//	foreach (CommandDef cd in fd.commands) {
					//		if (!string.IsNullOrEmpty (cd.alias))
					//			continue;
					//		if (preloadedCommands.Contains (cd.Name))
					//			continue;
					//		tw.WriteLine ($"LoadingUtils.GetDelegate (dev, \"{cd.Name + "\",",-54} ref {cd.Name + "_ptr"});");
					//	}
					//}
					tw.Indent--;
					tw.WriteLine (@"}");
					#endregion

					tw.Indent--;
					tw.WriteLine (@"}");

					tw.Indent--;
					tw.WriteLine (@"}");
				}
			}
		}
		#endregion

		#region vk.xml parsing
		static void readType (XmlNode nType) {
		 
			if (nType.Attributes ["alias"] != null) {
				aliases.Add (nType.Attributes["name"].Value, nType.Attributes["alias"].Value);
				return;
			}

			TypeCategories category = TypeCategories.none;
			if (nType.Attributes["category"] != null)
				category = (TypeCategories)Enum.Parse (typeof (TypeCategories), nType.Attributes["category"].Value, true);
			switch (category) {
				case TypeCategories.none:
					return;
				case TypeCategories.basetype:
					types.Add (new TypeDef {
						category = category,
						Name = nType["name"].InnerText,
						baseType = nType["type"].InnerText
					});
					break;
				case TypeCategories.bitmask:
					TypeDef ed = new TypeDef {
						category = category,
						Name = nType["name"].InnerText
					};
					if (nType.Attributes ["requires"] == null)
						ed.baseType = nType["type"].InnerXml;
					else
						ed.require = nType.Attributes["requires"].Value;
					types.Add (ed);
					break;
				case TypeCategories.handle:
					types.Add (new HandleDef {
						category = category,
						Name = nType["name"].InnerText,
						baseType = nType["type"]?.InnerText,
						parent = nType.Attributes["parent"]?.Value
					});
					break;
				case TypeCategories.funcpointer:
					FuncpointerDef fp = new FuncpointerDef {
						category = category,
						Name = nType["name"].InnerText
					};
					string returnTypeStr = nType.InnerText.Substring(8);//trim leading typedef
					returnTypeStr = returnTypeStr.Remove (returnTypeStr.IndexOf ('(')).Trim();
					switch (returnTypeStr) {
						case "void":
							fp.returnType = new ParamDef () { Name = "void" };
							break;
						case "void*":
							fp.returnType = new ParamDef () { Name = "IntPtr" };
							break;
						default:
							fp.returnType = new ParamDef () { Name = returnTypeStr };
							break;
					}
					types.Add (fp);
					break;
				case TypeCategories.@enum:
					types.Add (new TypeDef {
						category = category,
						Name = nType.Attributes["name"].Value,
					});
					break;
				case TypeCategories.define:
					Console.ForegroundColor = ConsoleColor.Cyan;
					Console.WriteLine (nType.InnerXml);
					break;
				case TypeCategories.include:
				case TypeCategories.group:
				case TypeCategories.union:
					Console.ForegroundColor = ConsoleColor.DarkMagenta;
					Console.WriteLine ($"Unprocessed type category {category}: {nType.OuterXml}");
					Console.ForegroundColor = ConsoleColor.Gray;
					break;
				case TypeCategories.@struct:
					StructDef sd = new StructDef {
						Name = nType.Attributes["name"].Value,
						category = category
					};
					foreach (XmlNode m in nType.ChildNodes) {
						if ((m.NodeType != XmlNodeType.Element)) {
							Console.WriteLine ($"expecting element, having {m.NodeType}: {m.OuterXml}");
							continue;
						}
						switch (m.Name) {
							case "comment":
								break;
							case "member":
								sd.members.Add (parseMember (m));
								break;
							default:
								Console.ForegroundColor = ConsoleColor.Red;
								Console.WriteLine ($"unknown element in struct def : {m.OuterXml}");
								Console.ForegroundColor = ConsoleColor.Gray;
								break;
						}
					}
					types.Add (sd);
					break;					
				default:
					Console.ForegroundColor = ConsoleColor.DarkMagenta;
					Console.WriteLine ($"Unprocessed type: {nType.OuterXml}");
					Console.ForegroundColor = ConsoleColor.Gray;
					break;
			}
		}
		public static void readEnum (XmlNode nEnum) {
			if (nEnum.Attributes ["name"]?.Value == "API Constants") {
				//constants
				foreach (XmlNode c in nEnum.ChildNodes) {
					if (c.Name != "enum")
						throw new Exception ("unexpected element in enums");
					if (c.Attributes ["alias"] != null) {
						aliases.Add (c.Attributes["name"].Value, c.Attributes["alias"].Value);
						continue;
					}

					Constants.Add (new EnumerantValue {
						Name = c.Attributes["name"].Value,
						value = c.Attributes["value"].Value,
						comment = c.Attributes["comment"]?.Value
					});
				}
				return;
			}
			EnumDef ed = new EnumDef {
				type = (EnumTypes)Enum.Parse (typeof (EnumTypes), nEnum.Attributes["type"].Value, true),
				Name = nEnum.Attributes["name"].Value
			};

			EnumerantValue ev = new EnumerantValue ();
			foreach (XmlNode p in nEnum.ChildNodes) {
				if (p.Name == "comment") {
					ev.comment = p.InnerXml;
					continue;
				} 

				if (p.Name == "unused") {
					ev.unusedComment = p.InnerXml;
					continue;
				}

				ev.Name = p.Attributes["name"].Value;
				ev.comment = p.Attributes["comment"]?.Value;

				if (ed.type == EnumTypes.bitmask) {
					if (p.Attributes["bitpos"] != null)
						ev.value = (1u << int.Parse (p.Attributes["bitpos"].Value)).ToString ();
					else
						ev.value = p.Attributes["value"]?.Value;
				} else if (p.Attributes["alias"] != null) {
					ev.isAlias = true;
					ev.value = p.Attributes["alias"].Value;
				} else
					ev.value = p.Attributes["value"].Value;

				ed.values.Add (ev);
				ev = new EnumerantValue ();
			}

			enums.Add (ed);
		}

		static void parseRequirements (InterfaceDef iface, XmlNode requirements) {
			if (requirements.Attributes["comment"]?.Value == "API constants") {
				//CONSTANTS
				foreach (XmlNode req in requirements.ChildNodes) {
					switch (req.Name) {
						case "enum":
							EnumerantValue ev = Constants.Where (v => v.Name == req.Attributes["name"].Value).First ();
							ev.definedBy.Add (iface.Name);
							break;
						default:
							Console.ForegroundColor = ConsoleColor.Red;
							Console.WriteLine ($"unhandle requirement tag in constants defs: {req.Attributes["name"].Value}");
							break;
					}
				}
				return;
			}

			foreach (XmlNode req in requirements.ChildNodes) {
				switch (req.Name) {
					case "type":
						switch (requirements.Attributes["comment"]?.Value) {
							case "Header boilerplate":
								break;
							case "API version":
								break;
							default:
								TypeDef tdef = types.Where (td => td.Name == req.Attributes["name"].Value).FirstOrDefault ();
								if (tdef != null) {
									tdef.definedBy.Add (iface.Name);
								}else{
									Console.ForegroundColor = ConsoleColor.DarkRed;
									Console.WriteLine ($"iface type not found: {req.Attributes["name"].Value}");
								}
								//try {
								//	if (iface.types.Any (td => td.Name == req.Attributes["name"].Value)) { 
								//		Console.ForegroundColor = ConsoleColor.DarkYellow;
								//		Console.WriteLine ($"iface already contain type: {req.Attributes["name"].Value}");
								//	}else
								//		iface.types.Add (commons.types.Where (td => td.Name == req.Attributes["name"].Value).First());
								//} catch {
								//	Console.ForegroundColor = ConsoleColor.DarkRed;
								//	Console.WriteLine ($"iface type not found: {req.Attributes["name"].Value}");
								//}
								break;
						}
						break;
					case "command":
						if (preloadedCommands.Contains (req.Attributes["name"].Value))//dont move those func
							continue;
						try {
							CommandDef cd = commands.Where (e => e.Name == req.Attributes["name"].Value).First ();
							cd.definedBy.Add (iface.Name);
						} catch {
							Console.ForegroundColor = ConsoleColor.Red;
							Console.WriteLine ($"extension command not found: {req.Attributes["name"].Value}");
						}
						break;
					case "enum":
						string eName = req.Attributes["name"].Value;
						if (skipEnums.Contains (eName))
							continue;
						EnumerantValue ev = extends.Where (e => e.Name == eName).FirstOrDefault ();
						if (ev != null) {
							ev.definedBy.Add (iface.Name);
							continue;
						}
						if (req.Attributes["value"] != null) {
							extends.Add (new EnumerantValue {
								Name = eName,
								definedBy = new List<string> { iface.Name },
								extends = req.Attributes["extends"]?.Value,
								value = req.Attributes["value"].Value
							});
						} else if (req.Attributes["bitpos"] != null) {
							extends.Add (new EnumerantValue {
								Name = eName,
								definedBy = new List<string> { iface.Name },
								extends = req.Attributes["extends"]?.Value,
								value = (1u << int.Parse (req.Attributes["bitpos"].Value)).ToString ()
							});
						} else if (req.Attributes["alias"] != null) {
							extends.Add (new EnumerantValue {
								Name = eName,
								definedBy = new List<string> { iface.Name },
								isAlias = true,
								extends = req.Attributes["extends"]?.Value,
								value = req.Attributes["alias"].Value
							});	
						} else if (req.Attributes["offset"] != null) {
							int offset = 0, extnumber = 0;
							int.TryParse (req.Attributes["offset"].Value, out offset);
							if (req.Attributes["extnumber"] != null)
								int.TryParse (req.Attributes["extnumber"].Value, out extnumber);
							int eval = extBase;
							if (extnumber > 0)
								eval += offset + (extnumber - 1) * extBlockSize;
							else
								eval += offset + (iface.number - 1) * extBlockSize;

							if (req.Attributes["dir"] != null)
								eval = -eval;

							extends.Add (new EnumerantValue {
								Name = eName,
								definedBy = new List<string> { iface.Name },
								extends = req.Attributes["extends"]?.Value,
								value = eval.ToString ()
							});
						} else //constant
							Constants.Add (new EnumerantValue {
								Name = eName,
								definedBy = new List<string> { iface.Name },
								extends = req.Attributes["extends"]?.Value,
							});
						break;
					default:
						Console.ForegroundColor = ConsoleColor.DarkRed;
						Console.WriteLine ($"unknown req: {req.OuterXml}");
						break;
				}
			}
		}

		public static void readExtension (XmlNode nExt) {
			ExtensionDef ext = new ExtensionDef ();
			ext.Name = nExt.Attributes["name"].Value;
			if (nExt.Attributes["number"] != null)
				ext.number = int.Parse (nExt.Attributes["number"].Value);
			if (nExt.Attributes["requires"] != null)
				ext.requires = nExt.Attributes["requires"].Value.Split (new char[] { ',' }, StringSplitOptions.RemoveEmptyEntries);
			if (nExt.Attributes["supported"] != null)
				ext.supported = nExt.Attributes["supported"].Value;
			if (nExt.Attributes["type"] != null)
				ext.type = (ExtensionType)Enum.Parse (typeof (ExtensionType), nExt.Attributes["type"].Value, true);

			foreach (XmlNode n in nExt.ChildNodes) {
				if (n.Name == "require") {
					parseRequirements (ext, n);
				} else if (n.Name == "remove") {
					Console.ForegroundColor = ConsoleColor.Blue;
					Console.WriteLine ($"extension remove: {n.OuterXml}");
				} else
					Debugger.Break ();
			}

			extensions.Add (ext);
		}

		public static void readFeature (XmlNode nFeat) {
			FeatureDef fd = new FeatureDef ();
			fd.number = 1;
			fd.Name = nFeat.Attributes["name"].Value;
			fd.api = nFeat.Attributes["api"].Value;
			string[] version = nFeat.Attributes["number"].Value.Split ('.');
			fd.major = int.Parse (version[0]);
			fd.minor = int.Parse (version[1]);
			fd.comment = nFeat.Attributes["comment"]?.Value;

			//extensions.Add (new EnumerantDef { Name = "constants" });

			foreach (XmlNode f in nFeat.ChildNodes) {
				if (f.Name == "require") {
					parseRequirements (fd, f);
				} else if (f.Name == "remove") {
					Console.ForegroundColor = ConsoleColor.DarkBlue;
					Console.WriteLine ($"feature remove: {f.OuterXml}");
				} else
					Debugger.Break ();
			}

			features.Add (fd);
		}


		static MemberDef parseMember (XmlNode np) {
			MemberDef md = new MemberDef () { typedef = ParamDef.parse (np) };
			if (np.Attributes["optional"] != null)
				md.optional = true;

			md.lenMember = np.Attributes["len"]?.Value;
			md.defaultValue = np.Attributes["values"]?.Value;
			md.optional = np.Attributes["optional"] != null;//could handle both case
			md.externsync = np.Attributes["externsync"] != null;

			md.Name = np["name"].InnerText;
			if (reservedNames.Contains (md.Name))
				md.Name = "_" + md.Name;

			XmlNode ns = np["name"].NextSibling;
			if (ns?.NodeType == XmlNodeType.Text && ns.Value.StartsWith ("[",StringComparison.Ordinal)) {
				if (np["enum"] != null) {
					md.fixedArray = np["enum"].InnerXml;
				} else
					md.fixedArray = ns.Value.Substring(1, ns.InnerText.Length-2);
			}



			md.comment = np["comment"]?.InnerText;

			return md;
		}

		public static void readCommand (XmlNode ncmd) {
			CommandDef cd = new CommandDef ();

			if (ncmd.Attributes ["alias"] != null) {
				cd.Name = ncmd.Attributes ["name"].Value;
				cd.alias = ncmd.Attributes["alias"].Value;
			} else {
				cd.successCodes = ncmd.Attributes["successcodes"]?.Value;
				cd.errorcodes = ncmd.Attributes["errorcodes"]?.Value;

				XmlNode n = ncmd["proto"];
				cd.returnType = ParamDef.parse (n);
				cd.Name = n["name"].InnerText;
				n = n.NextSibling;
				while (n != null) {
					if (n.Name == "param")
						cd.parameters.Add (parseMember (n));
					else if (n.Name == "implicitexternsyncparams")
						cd.comment = n.InnerText;

					n = n.NextSibling;
				}
			}
			commands.Add (cd);
		}
		#endregion

		public static void Main (string[] args) {
			XmlDocument doc = new XmlDocument ();
			doc.Load ("vk.xml");

			//Console.WriteLine ("===== PLATFORMS =======");
			//foreach (XmlNode p in doc.GetElementsByTagName ("platforms").Item (0)) {
			//	Console.WriteLine ($"{p.GetAttribute ("name"),-20}{p.GetAttribute ("protect"),-50}{p.GetAttribute ("comment")}");
			//}

			foreach (XmlNode p in doc.GetElementsByTagName ("tags").Item (0)) 
				tags.Add (p.Attributes["name"].Value.ToString ());

			foreach (XmlNode p in doc.GetElementsByTagName ("types").Item (0)) 
				readType (p);

			XmlNodeList enumsNL = doc.GetElementsByTagName ("enums");
			for (int i = 0; i < enumsNL.Count; i++)
				readEnum (enumsNL.Item (i));

			foreach (XmlNode e in doc.GetElementsByTagName ("commands").Item (0)) {
				if (e.Name == "command")
					readCommand (e);
				else
					Console.WriteLine ($"commands: {e.OuterXml}");
			}

			foreach (XmlNode e in doc.GetElementsByTagName ("extensions").Item (0)) {
				if (e.Name == "extension")
					readExtension (e);
				else
					Console.WriteLine ($"extension: {e.OuterXml}");
			}

			XmlNodeList featuresNL = doc.GetElementsByTagName ("feature");
			for (int i = 0; i < featuresNL.Count; i++)
				readFeature (featuresNL.Item (i));
				
			gen_constants ("Vk");
			gen_enums ("Vk");
			gen_structs ("Vk");
			gen_commands ("Vk");
			gen_handles ("Vk");
			gen_funcptrs ("Vk");

			gen_extensions ();
		}

	}
}
